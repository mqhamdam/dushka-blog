// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'wall_filter.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$WallFilterTearOff {
  const _$WallFilterTearOff();

  _WallFilter call(
      {required bool isRandom,
      required bool isTrending,
      required bool onlySubscribers,
      required UserUID userUID,
      required PostID postID,
      required int minLikes,
      required int minComments}) {
    return _WallFilter(
      isRandom: isRandom,
      isTrending: isTrending,
      onlySubscribers: onlySubscribers,
      userUID: userUID,
      postID: postID,
      minLikes: minLikes,
      minComments: minComments,
    );
  }
}

/// @nodoc
const $WallFilter = _$WallFilterTearOff();

/// @nodoc
mixin _$WallFilter {
  bool get isRandom => throw _privateConstructorUsedError;
  bool get isTrending => throw _privateConstructorUsedError;
  bool get onlySubscribers => throw _privateConstructorUsedError;
  UserUID get userUID => throw _privateConstructorUsedError;
  PostID get postID => throw _privateConstructorUsedError;
  int get minLikes => throw _privateConstructorUsedError;
  int get minComments => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WallFilterCopyWith<WallFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WallFilterCopyWith<$Res> {
  factory $WallFilterCopyWith(
          WallFilter value, $Res Function(WallFilter) then) =
      _$WallFilterCopyWithImpl<$Res>;
  $Res call(
      {bool isRandom,
      bool isTrending,
      bool onlySubscribers,
      UserUID userUID,
      PostID postID,
      int minLikes,
      int minComments});
}

/// @nodoc
class _$WallFilterCopyWithImpl<$Res> implements $WallFilterCopyWith<$Res> {
  _$WallFilterCopyWithImpl(this._value, this._then);

  final WallFilter _value;
  // ignore: unused_field
  final $Res Function(WallFilter) _then;

  @override
  $Res call({
    Object? isRandom = freezed,
    Object? isTrending = freezed,
    Object? onlySubscribers = freezed,
    Object? userUID = freezed,
    Object? postID = freezed,
    Object? minLikes = freezed,
    Object? minComments = freezed,
  }) {
    return _then(_value.copyWith(
      isRandom: isRandom == freezed
          ? _value.isRandom
          : isRandom // ignore: cast_nullable_to_non_nullable
              as bool,
      isTrending: isTrending == freezed
          ? _value.isTrending
          : isTrending // ignore: cast_nullable_to_non_nullable
              as bool,
      onlySubscribers: onlySubscribers == freezed
          ? _value.onlySubscribers
          : onlySubscribers // ignore: cast_nullable_to_non_nullable
              as bool,
      userUID: userUID == freezed
          ? _value.userUID
          : userUID // ignore: cast_nullable_to_non_nullable
              as UserUID,
      postID: postID == freezed
          ? _value.postID
          : postID // ignore: cast_nullable_to_non_nullable
              as PostID,
      minLikes: minLikes == freezed
          ? _value.minLikes
          : minLikes // ignore: cast_nullable_to_non_nullable
              as int,
      minComments: minComments == freezed
          ? _value.minComments
          : minComments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$WallFilterCopyWith<$Res> implements $WallFilterCopyWith<$Res> {
  factory _$WallFilterCopyWith(
          _WallFilter value, $Res Function(_WallFilter) then) =
      __$WallFilterCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isRandom,
      bool isTrending,
      bool onlySubscribers,
      UserUID userUID,
      PostID postID,
      int minLikes,
      int minComments});
}

/// @nodoc
class __$WallFilterCopyWithImpl<$Res> extends _$WallFilterCopyWithImpl<$Res>
    implements _$WallFilterCopyWith<$Res> {
  __$WallFilterCopyWithImpl(
      _WallFilter _value, $Res Function(_WallFilter) _then)
      : super(_value, (v) => _then(v as _WallFilter));

  @override
  _WallFilter get _value => super._value as _WallFilter;

  @override
  $Res call({
    Object? isRandom = freezed,
    Object? isTrending = freezed,
    Object? onlySubscribers = freezed,
    Object? userUID = freezed,
    Object? postID = freezed,
    Object? minLikes = freezed,
    Object? minComments = freezed,
  }) {
    return _then(_WallFilter(
      isRandom: isRandom == freezed
          ? _value.isRandom
          : isRandom // ignore: cast_nullable_to_non_nullable
              as bool,
      isTrending: isTrending == freezed
          ? _value.isTrending
          : isTrending // ignore: cast_nullable_to_non_nullable
              as bool,
      onlySubscribers: onlySubscribers == freezed
          ? _value.onlySubscribers
          : onlySubscribers // ignore: cast_nullable_to_non_nullable
              as bool,
      userUID: userUID == freezed
          ? _value.userUID
          : userUID // ignore: cast_nullable_to_non_nullable
              as UserUID,
      postID: postID == freezed
          ? _value.postID
          : postID // ignore: cast_nullable_to_non_nullable
              as PostID,
      minLikes: minLikes == freezed
          ? _value.minLikes
          : minLikes // ignore: cast_nullable_to_non_nullable
              as int,
      minComments: minComments == freezed
          ? _value.minComments
          : minComments // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_WallFilter implements _WallFilter {
  const _$_WallFilter(
      {required this.isRandom,
      required this.isTrending,
      required this.onlySubscribers,
      required this.userUID,
      required this.postID,
      required this.minLikes,
      required this.minComments});

  @override
  final bool isRandom;
  @override
  final bool isTrending;
  @override
  final bool onlySubscribers;
  @override
  final UserUID userUID;
  @override
  final PostID postID;
  @override
  final int minLikes;
  @override
  final int minComments;

  @override
  String toString() {
    return 'WallFilter(isRandom: $isRandom, isTrending: $isTrending, onlySubscribers: $onlySubscribers, userUID: $userUID, postID: $postID, minLikes: $minLikes, minComments: $minComments)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _WallFilter &&
            const DeepCollectionEquality().equals(other.isRandom, isRandom) &&
            const DeepCollectionEquality()
                .equals(other.isTrending, isTrending) &&
            const DeepCollectionEquality()
                .equals(other.onlySubscribers, onlySubscribers) &&
            const DeepCollectionEquality().equals(other.userUID, userUID) &&
            const DeepCollectionEquality().equals(other.postID, postID) &&
            const DeepCollectionEquality().equals(other.minLikes, minLikes) &&
            const DeepCollectionEquality()
                .equals(other.minComments, minComments));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isRandom),
      const DeepCollectionEquality().hash(isTrending),
      const DeepCollectionEquality().hash(onlySubscribers),
      const DeepCollectionEquality().hash(userUID),
      const DeepCollectionEquality().hash(postID),
      const DeepCollectionEquality().hash(minLikes),
      const DeepCollectionEquality().hash(minComments));

  @JsonKey(ignore: true)
  @override
  _$WallFilterCopyWith<_WallFilter> get copyWith =>
      __$WallFilterCopyWithImpl<_WallFilter>(this, _$identity);
}

abstract class _WallFilter implements WallFilter {
  const factory _WallFilter(
      {required bool isRandom,
      required bool isTrending,
      required bool onlySubscribers,
      required UserUID userUID,
      required PostID postID,
      required int minLikes,
      required int minComments}) = _$_WallFilter;

  @override
  bool get isRandom;
  @override
  bool get isTrending;
  @override
  bool get onlySubscribers;
  @override
  UserUID get userUID;
  @override
  PostID get postID;
  @override
  int get minLikes;
  @override
  int get minComments;
  @override
  @JsonKey(ignore: true)
  _$WallFilterCopyWith<_WallFilter> get copyWith =>
      throw _privateConstructorUsedError;
}
